<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
<title>RIP John McCarthy &laquo;  Programming Praxis</title>
</head>
<body>
<div class="entrytitle">
<h2>RIP John&nbsp;McCarthy</h2>
<h3>November 1, 2011</h3>
</div>
<div class="entrybody">
<p>John McCarthy, the inventor of Lisp, died on October 23, 2011. In his honor we will implement a Lisp interpreter in today&#8217;s exercise. He first described Lisp in an <a href="http://www-formal.stanford.edu/jmc/recursive.pdf">academic paper</a>, and the <a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">LISP 1.5 Programmer&#8217;s Manual</a>, published in 1962 but still in print, is an early definition of the language (the LISP 1.0 manual by Patricia Fox was dated 1960, which is usually cited as the birth year of Lisp, even though Lisp was formally specified as early as 1958). McCarthy defines the eval/apply yin/yang that is at the heart of Lisp on page 13, in what Alan Kay <a href="http://queue.acm.org/detail.cfm?id=1039523">described</a> as the Maxwell&#8217;s equations of software. We begin with the definition of <code>apply</code>:</p>
<p><code>apply[fn;x;a] =<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[atom[fn] &rarr; [eq[fn;CAR] &rarr; caar[x];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq[fn;CDR] &rarr; cdar[x];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq[fn;CONS] &rarr; cons[car[x];cadr[x]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq[fn;ATOM] &rarr; atom[car[x]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq[fn;EQ] &rarr; eq[car[x];cadr[x]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T &rarr; apply[eval[fn;a];x;a]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq[car[fn];LAMBDA] &rarr; eval[caddr[fn]; pairlis[cadr[fn];x;a]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq[car[fn];LABEL] &rarr; apply[caddr[fn];x;cons[cons[cadr[fn];caddr[fn]];a]]]</code></p>
<p><code>Apply</code> interprets expressions. The first clause dispatches on the various built-in functions of Lisp, calling the underlying language (in this case, Lisp, since this is a <em>meta-circular</em> evaluator) to evaluate the function. The second clause evaluates functions defined by <code>lambda</code> by calling <code>eval</code>. The third clause is special; it evaluates recursive functions defined by <code>label</code> by first adding the function to the environment, then calling <code>apply</code> recursively to evaluate the new function. <code>Apply</code> uses an auxiliary function <code>pairlis</code> to insert function definitions in the environment <code>a</code>; as an example, <code>pairlis[(A B C);(U V W);((D . X) (E . Y))]</code> evaluates to <code>((A . U) (B . V) (C . W) (D . X) (E . Y))</code>:</p>
<p><code>pairlis[x;y;a] = [null[x] &rarr; a; T &rarr; cons[cons[car[x];car[y]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pairlis[cdr[x];cdr[y];a]]]</code></p>
<p><code>Eval</code> handles statements, which are known as <em>special forms</em> in the parlance of Lisp. In a function, the elements of an expression are all evaluated before the function at the head of the expression is called, but in a statement the order of evaluation may change; for instance, in an <code>if</code> statement only one of the two consequents is evaluated. Here is <code>eval</code>:</p>
<p><code>eval[e;a] = [atom[e] &rarr; cdr[assoc[e;a]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atom[car[e]] &rarr;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[eq[car[e];QUOTE] &rarr; cadr[e];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq[car[e];COND] &rarr; evcon[cdr[e];a];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T &rarr; apply[car[e];evlis[cdr[e];a];a]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T &rarr; apply[car[e];evlis[cdr[e];a];a]]</code></p>
<p><code>Eval</code> handles two special forms: <code>Quote</code> handles its argument literally rather than evaluating it as an expressions. <code>Cond</code> executes code conditionally, checking the predicate of each clause until it finds one that is true, when it evaluates the associated expression. <code>Eval</code> uses three auxiliary functions. The first is <code>assoc</code>, which performs a lookup in an environment; for instance, <code>assoc[B;((A . (M N)), (B . (CAR X)), (C . (QUOTE M)), (C . (CDR X)))]</code> evaluates to <code>(B . (CAR X))</code>:</p>
<p><code>assoc[x;a] = [equal[caar[a];x]&rarr;car[a]; T &rarr; assoc[x;cdr[a]]]</code></p>
<p><code>Evcon</code> interprets a <code>cond</code> statement, evaluating the predicate of each clause, then evaluating the expression associated with the first predicate that is true:</p>
<p><code>evcon[c;a] = [eval[caar[c];a] &rarr; eval[cadar[c];a];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T &rarr; evcon[cdr[c];a]]</code></p>
<p><code>Evlis</code> evaluates the elements of a list, in order, returning a new list with the results of each evaluation:</p>
<p><code>evlis[m;a] = [null[m] &rarr; NIL;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T &rarr; cons[eval[car[m];a];evlis[cdr[m];a]]]</code></p>
<p>Finally, <code>evalquote</code> is the entrance to the evaluator:</p>
<p><code>evalquote[fn;x] = apply[fn;x;NIL]</code></p>
<p>Your task is to implement a simple Lisp interpreter in the style of John McCarthy. When you are finished, you are welcome to <a href="/2011/11/01/rip-john-mccarthy/2/">read</a> or <a href="http://programmingpraxis.codepad.org/8cfeZ3ER">run</a> a suggested solution, or to post your own solution or discuss the exercise in the comments below.</p>
<div id="wpcom_below_post" class="wpadvert" style="text-align: center; padding: 5px; background: #; padding: 5px; margin: 10px auto; width: 310px;">
<!-- <span style="text-align: left; letter-spacing: 1px; font: 8px/1em Verdana, sans-serif; color: #ccc; text-transform: uppercase; display: block; padding: 0 1px;">Advertisement</span> -->
<script type="text/javascript">
LD_AddCustomAttr("AdOpt", "1");
LD_AddCustomAttr("Origin", "other");
LD_AddCustomAttr("theme_bg", "ffffff"); 
LD_AddCustomAttr("theme_text", "555555"); 
LD_AddCustomAttr("theme_link", "557799"); 
LD_AddCustomAttr("theme_border", "C8A799"); 
LD_AddCustomAttr("theme_url", "8FB1D3"); 
LD_AddCustomAttr("LangId", "1");
LD_AddCustomAttr("Autotag", "gadgets");
LD_AddCustomAttr("Tag", "exercises");

LD_AddSlot("wpcom_below_post");
LD_GetBids();
</script>
</div><div class="sharedaddy sd-like-enabled"><div id="wpl-likebox" class="sd-block sd-like"><h3 class="sd-title">Like this:</h3><div class="sd-content"><div id="wpl-button"><a href="http://programmingpraxis.com/2011/11/01/rip-john-mccarthy/?like=1&amp;_wpnonce=a72c2c6ab5" title="I like this post" class="like needs-login sd-button" rel="nofollow"><span>Like</span></a></div><div id="wpl-count" class="sd-like-count">Be the first to like this post.</div></div></div></div> <p>Pages: 1 <a href="http://programmingpraxis.com/2011/11/01/rip-john-mccarthy/2/">2</a></p> </div></div>
</body>
</html>
