<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
<title>The Next Prime &laquo;  Programming Praxis</title>
</head>
<body>
<div class="entrytitle">
<h2>The Next&nbsp;Prime</h2>
<h3>March 26, 2010</h3>
</div>
<div class="entrybody">
<p>In two <a href="/2009/04/14/google-treasure-hunt-2008-puzzle-4/">previous</a> <a href="/2010/03/02/goldbachs-conjecture/">exercises</a>, we had to iterate through the prime numbers.  In one case, we generated a large number of primes using the Sieve of Eratosthenes, but without knowing in advance how large the sieve needed to be, and in the other case we iterated through the odd integers, checking the primality of each.  Both solutions were less than attractive.  In consideration of the old rule that if you do something twice you ought to build it into an abstraction, we will today write a function that, given a positive integer <em>n</em>, returns the smallest prime number greater than <em>n</em>.</p>
<p>Our method is to pre-compute a large number of primes and store them on disk.  If <em>n</em> is within the bounds of the pre-computed list, it is easy to find the next prime.  But if <em>n</em> is too large, we revert to checking individual candidates for primality.  For our example we will pre-compute the primes to a million, but depending on your aspirations and your memory budget, you could adjust that number as desired.</p>
<p>To save memory space, we will store the pre-computed primes in a compressed data structure.  Every prime number can be expressed as 30<em>k</em>&plusmn;1, 30<em>k</em>&plusmn;7, 30<em>k</em>&plusmn;11, or 30<em>k</em>&plusmn;13 for some <em>k</em>.  That means we can use eight bits per thirty numbers to store all the primes; a million primes can be compressed to 33,334 bytes, plus a small program to load the compressed primes from disk and to manipulate the compressed data structure.</p>
<p>Your task is to write a function that builds the compressed data structure described above, a second function that loads it from disk to memory, and a third function that uses the compressed data structure to calculate the next prime.  When you are finished, you are welcome to <a href="/2010/03/26/the-next-prime/2/">read</a> or <a href="http://programmingpraxis.codepad.org/KwCJJfYH">run</a> a suggested solution, or to post your own solution or discuss the exercise in the comments below.</p>
<div id="wpcom_below_post" class="wpadvert" style="text-align: center; padding: 5px; background: #; padding: 5px; margin: 10px auto; width: 310px;">
<!-- <span style="text-align: left; letter-spacing: 1px; font: 8px/1em Verdana, sans-serif; color: #ccc; text-transform: uppercase; display: block; padding: 0 1px;">Advertisement</span> -->
<script type="text/javascript">
LD_AddCustomAttr("AdOpt", "1");
LD_AddCustomAttr("Origin", "other");
LD_AddCustomAttr("theme_bg", "ffffff"); 
LD_AddCustomAttr("theme_text", "555555"); 
LD_AddCustomAttr("theme_link", "557799"); 
LD_AddCustomAttr("theme_border", "C8A799"); 
LD_AddCustomAttr("theme_url", "8FB1D3"); 
LD_AddCustomAttr("LangId", "1");
LD_AddCustomAttr("Autotag", "technology");
LD_AddCustomAttr("Autotag", "entertainment");
LD_AddCustomAttr("Tag", "exercises");

LD_AddSlot("wpcom_below_post");
LD_GetBids();
</script>
</div><div class="sharedaddy sd-like-enabled"><div id="wpl-likebox" class="sd-block sd-like"><h3 class="sd-title">Like this:</h3><div class="sd-content"><div id="wpl-button"><a href="http://programmingpraxis.com/2010/03/26/the-next-prime/?like=1&amp;_wpnonce=a72c2c6ab5" title="I like this post" class="like needs-login sd-button" rel="nofollow"><span>Like</span></a></div><div id="wpl-count" class="sd-like-count">Be the first to like this post.</div></div></div></div> <p>Pages: 1 <a href="http://programmingpraxis.com/2010/03/26/the-next-prime/2/">2</a></p> </div></div>
</body>
</html>
