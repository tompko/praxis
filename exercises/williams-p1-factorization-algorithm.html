<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
<title>Williams&#8217; P+1 Factorization Algorithm &laquo;  Programming Praxis</title>
</head>
<body>
<div class="entrytitle">
<h2>Williams&#8217; <em>P</em>+1 Factorization&nbsp;Algorithm</h2>
<h3>June 4, 2010</h3>
</div>
<div class="entrybody">
<p>Hugh Williams invented the <em>p</em>+1 integer factorization method in 1982 based on John Pollard&#8217;s <em>p</em>-1 integer factorization method; the <em>p</em>+1 method finds a factor <em>p</em> when <em>p</em> is smooth with respect to a bound <em>B</em>.  We noted in a previous <a href="/2010/04/27/modern-elliptic-curve-factorization-part-2/">exercise</a> the similar structure of Pollard&#8217;s <em>p</em>-1 method and Lenstra&#8217;s elliptic curve method, and Williams&#8217; <em>p</em>+1 method shares the same two-stage structure; Pollard&#8217;s <em>p</em>-1 method performs multiplications modulo <em>p</em>, Lenstra&#8217;s elliptic curve method performs multiplications over an elliptic curve, and Williams&#8217; <em>p</em>+1 method performs multiplications over a quadratic field using Lucas sequences (similar to the Lucas chain in the Baillie-Wagstaff primality-testing <a href="/2010/01/26/primality-checking-revisited/">exercise</a>).  A good description of Williams&#8217; <em>p</em>+1 method is given at <a href="http://www.mersennewiki.org/index.php/P_Plus_1_Factorization_Method">http://www.mersennewiki.org/index.php/P_Plus_1_Factorization_Method</a>.</p>
<p>Williams&#8217; <em>p</em>+1 method uses the Lucas sequence <em>V</em><sub>0</sub> = 2, <em>V</em><sub>1</sub> = <em>A</em>, <em>V<sub>j</sub></em> = <em>A</em> &middot; <em>V</em><sub><em>j</em>&minus;1</sub> &minus; <em>V</em><sub><em>j</em>&minus;2</sub>, with all operations modulo <em>N</em>, where <em>A</em> is an integer greater than 2.  Multiplication by successive prime powers is done as in Pollard&#8217;s <em>p</em>-1 algorithm; when all the products to the bound <em>B</em> are accumulated, the greatest common divisor of <em>N</em> and the result <em>V</em><sub><em>B</em></sub> &minus; 2 may be a divisor of <em>N</em> if all the factors of <em>p</em>+1 are less than <em>B</em>.  However, if <em>A</em><sup>2</sup> &minus; 4 is a quadratic non-residue of <em>p</em>, the calculation will fail, so several attempts must be made with different values of <em>A</em> before concluding that <em>p</em>+1 is not <em>B</em>-smooth.</p>
<p>Given the addition formula <em>V</em><sub><em>m</em>+<em>n</em></sub> = <em>V<sub>m</sub></em> <em>V<sub>n</sub></em> &minus; <em>V</em><sub><em>m</em>&minus;<em>n</em></sub> and the doubling formula <em>V</em><sub><em>2m</em></sub> = <em>V</em><sub><em>m</em></sub> &times; <em>V</em><sub><em>m</em></sub> &minus; 2, multiplication is done by means of a Lucas sequence that computes two values at a time.  Starting with the pair <em>V<sub>kn</sub></em> and <em>V</em><sub>(<em>k</em>+1)<em>n</em></sub>, and looking at the bits in the binary representation of the multiplier <em>M</em>, excluding the most significant bit (which is always 1) and working from most significant to least significant, calculate the pair <em>V<sub>2kn</sub></em>, <em>V</em><sub>(2<em>k</em>+1)<em>n</em></sub> when the bit is zero and the pair <em>V</em><sub>(2<em>k</em>+1)<em>n</em></sub>, <em>V</em><sub>2(<em>k</em>+1)<em>n</em></sub> when the bit is one.</p>
<p>The second stage finds factors that are <em>B</em><sub>1</sub>-smooth except for a single prime factor in the range <em>B</em><sub>1</sub> to <em>B</em><sub>2</sub>.  It can be done in a similar manner to the second stage of Pollard&#8217;s <em>p</em>-1 method, but a little bit of algebra gives us a better second stage.  Assuming that <em>V<sub>n</sub></em> is the point that survives the first stage, multiply the products <em>V<sub>k</sub></em> &minus; <em>V<sub>n</sub></em> for each <em>k</em> divisible by 6 between <em>B</em><sub>1</sub> and <em>B</em><sub>2</sub>, then take the greatest common divisor of the product with <em>n</em> to reveal the factor.</p>
<p>Your task is to write a program that factors integers using Williams&#8217; <em>p</em>+1 algorithm.  When you are finished, you are welcome to <a href="/2010/06/04/williams-p1-factorization-algorithm/2/">read</a> or <a href="http://programmingpraxis.codepad.org/gAMB9T4D">run</a> a suggested solution, or to post your own solution or discuss the exercise in the comments below.</p>
<div id="wpcom_below_post" class="wpadvert" style="text-align: center; padding: 5px; background: #; padding: 5px; margin: 10px auto; width: 310px;">
<!-- <span style="text-align: left; letter-spacing: 1px; font: 8px/1em Verdana, sans-serif; color: #ccc; text-transform: uppercase; display: block; padding: 0 1px;">Advertisement</span> -->
<script type="text/javascript">
LD_AddCustomAttr("AdOpt", "1");
LD_AddCustomAttr("Origin", "other");
LD_AddCustomAttr("theme_bg", "ffffff"); 
LD_AddCustomAttr("theme_text", "555555"); 
LD_AddCustomAttr("theme_link", "557799"); 
LD_AddCustomAttr("theme_border", "C8A799"); 
LD_AddCustomAttr("theme_url", "8FB1D3"); 
LD_AddCustomAttr("LangId", "1");
LD_AddCustomAttr("Autotag", "technology");
LD_AddCustomAttr("Tag", "exercises");

LD_AddSlot("wpcom_below_post");
LD_GetBids();
</script>
</div><div class="sharedaddy sd-like-enabled"><div id="wpl-likebox" class="sd-block sd-like"><h3 class="sd-title">Like this:</h3><div class="sd-content"><div id="wpl-button"><a href="http://programmingpraxis.com/2010/06/04/williams-p1-factorization-algorithm/?like=1&amp;_wpnonce=a72c2c6ab5" title="I like this post" class="like needs-login sd-button" rel="nofollow"><span>Like</span></a></div><div id="wpl-count" class="sd-like-count">Be the first to like this post.</div></div></div></div> <p>Pages: 1 <a href="http://programmingpraxis.com/2010/06/04/williams-p1-factorization-algorithm/2/">2</a></p> </div></div>
</body>
</html>
